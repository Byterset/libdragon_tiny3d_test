#include "capsule.h"

#include "../physics_object.h"
#include <math.h>
#include "sphere.h"

// Generated by Copilot
void capsule_support_function(void* data, struct Vector3* direction, struct Vector3* output) {
    struct physics_object* object = (struct physics_object*)data;
    union physics_object_collision_shape_data* shape_data = &object->collision->shape_data;

    // Determine the point along the capsule's central axis that is furthest in `direction`
    float sign = (direction->y > 0.0f) ? 1.0f : -1.0f;
    struct Vector3 axis_point = { 0.0f, sign * shape_data->capsule.inner_half_height, 0.0f };

    // Offset by the capsule's radius in the direction of `direction`
    struct Vector3 radius_offset = {
        direction->x * shape_data->capsule.radius,
        direction->y * shape_data->capsule.radius,
        direction->z * shape_data->capsule.radius
    };

    // Combine the endpoint on the capsule's axis with the radius offset
    output->x = axis_point.x + radius_offset.x;
    output->y = axis_point.y + radius_offset.y;
    output->z = axis_point.z + radius_offset.z;
}


// Generated by Copilot
void capsule_bounding_box(void* data, Quaternion* rotation, struct AABB* box) {
    struct physics_object* object = (struct physics_object*)data;
    union physics_object_collision_shape_data* shape_data = &object->collision->shape_data;
    
    // Get capsule dimensions
    float half_height = shape_data->capsule.inner_half_height;
    float radius = shape_data->capsule.radius;
    float half_height_plus_radius = half_height + radius;

    // Define the capsule's central axis in local space
    struct Vector3 axis_min = { 0.0f, -half_height, 0.0f };
    struct Vector3 axis_max = { 0.0f,  half_height, 0.0f };

    // Rotate the axis endpoints
    struct Vector3 rotated_min, rotated_max;
    if (rotation) {
        quatMultVector(rotation, &axis_min, &rotated_min);
        quatMultVector(rotation, &axis_max, &rotated_max);
    } else {
        vector3Copy(&axis_min, &rotated_min);
        vector3Copy(&axis_max, &rotated_max);
    }

    // Calculate the bounding box
    box->min.x = fminf(rotated_min.x - radius, rotated_max.x - radius);
    box->min.y = fminf(rotated_min.y - radius, rotated_max.y - radius);
    box->min.z = fminf(rotated_min.z - radius, rotated_max.z - radius);

    box->max.x = fmaxf(rotated_min.x + radius, rotated_max.x + radius);
    box->max.y = fmaxf(rotated_min.y + radius, rotated_max.y + radius);
    box->max.z = fmaxf(rotated_min.z + radius, rotated_max.z + radius);
}
