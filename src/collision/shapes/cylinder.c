#include "cylinder.h"

#include "../physics_object.h"
#include "../../math/matrix.h"
#include <math.h>

#define SQRT_1_2   0.707106781f
#define SQRT_2 1.41421356237f

// Generated by Copilot
void cylinder_support_function(void* data, struct Vector3* direction, struct Vector3* output) {
    struct physics_object* object = (struct physics_object*)data;
    union physics_object_collision_shape_data* shape_data = &object->collision->shape_data;

    // Determine the point along the cylinder's central axis that is furthest in `direction`
    float sign = (direction->y > 0.0f) ? 1.0f : -1.0f;
    output->x = direction->x * shape_data->cylinder.radius;
    output->y = sign * shape_data->cylinder.half_height;
    output->z = direction->z * shape_data->cylinder.radius;

    // Normalize the x and z components to account for the radius
    float length = sqrtf(output->x * output->x + output->z * output->z);
    if (length > 0.0f) {
        output->x *= shape_data->cylinder.radius / length;
        output->z *= shape_data->cylinder.radius / length;
    }
}

void cylinder_bounding_box(void* data, struct Quaternion* rotation, struct AABB* box) {
    struct physics_object* object = (struct physics_object*)data;
    union physics_object_collision_shape_data* shape_data = &object->collision->shape_data;

    // Get capsule dimensions
    float half_height = shape_data->cylinder.half_height;
    float radius = shape_data->cylinder.radius;

    // Define the cylinders local aabb
    box->min = (struct Vector3){ -radius, -half_height, -radius };
    box->max = (struct Vector3){  radius,  half_height,  radius };


    // Rotate the local aabb if needed with Arvo's method
    if (rotation) {
        mat4x4 rotMat;
        struct AABB aabb_rotated = {0};
        quatToMatrix(rotation, rotMat);
        
        //for all three axes
        for(int i = 0; i < 3; i++){
            // Form extent by summing smaller and larger terms respectively
            for (int j = 0; j < 3; j++)
            {
                float a = rotMat[i][j] * (VECTOR3_AS_ARRAY(&box->min)[j]);
                float b = rotMat[i][j] * (VECTOR3_AS_ARRAY(&box->max)[j]);
                
                VECTOR3_AS_ARRAY(&aabb_rotated.min)[i] += (a < b) ? a : b;
                VECTOR3_AS_ARRAY(&aabb_rotated.max)[i] += (a < b) ? b : a;
            }
            
        }
        box->min = aabb_rotated.min;
        box->max = aabb_rotated.max;
    }

    


    // // Get capsule dimensions
    // float half_height = shape_data->cylinder.half_height;
    // float radius = shape_data->cylinder.radius;


    // // Define the capsule's central axis in local space
    // struct Vector3 corners[8] = { 
    //     {-radius, -half_height, -radius },
    //     { radius, -half_height, -radius },
    //     {-radius, -half_height,  radius },
    //     { radius, -half_height,  radius },
    //     {-radius,  half_height, -radius },
    //     { radius,  half_height, -radius },
    //     {-radius,  half_height,  radius },
    //     { radius,  half_height,  radius }
    // };
    // struct Vector3 new_min;
    // struct Vector3 new_max;

    // // Initialize new_min and new_max with the first rotated corner
    // struct Vector3 rotated_corner;
    // if(object->rotation)
    //     quatMultVector(object->rotation, &corners[0], &rotated_corner);
    // else
    //     vector3Copy(&corners[0], &rotated_corner);
    // new_min = rotated_corner;
    // new_max = rotated_corner;

    // for(int i = 1; i < 8; i++){
    //     if(object->rotation)
    //         quatMultVector(object->rotation, &corners[i], &rotated_corner);
    //     else
    //         vector3Copy(&corners[i], &rotated_corner);

    //     // Update new_min and new_max
    //     vector3Min(&new_min, &rotated_corner, &new_min);
    //     vector3Max(&new_max, &rotated_corner, &new_max);
    // }

    // box->min = new_min;
    // box->max = new_max;

}